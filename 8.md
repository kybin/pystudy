# 2018-03-18

지난 시간에는 아이템 박스를 까는 코드를 만들었었는데요.

제가 불만이었던 부분은 캐릭터든 캐쉬든 모든 아이템이 나올 확률이 똑같았다는 겁니다.
실제 게임에서는 좋은 아이템일 수록 얻게될 확률이 낮습니다. 보통 이런 아이템들을 전설템,
에픽템 등으로 부릅니다. 전설템이 나올 확률이 일반 아이템과 같다면 박스를 깔 때 아무도
두근두근하지 않을 겁니다.

그래서 오늘은 박스마다 나올 확률이 달라지도록 코드를 고쳐보려고 합니다. 확률이라니 엄청나군요.
이 어려운 걸 저희가 벌써 다룹니다. 오늘은 다들 떨어지지 않도록 손잡이를 단단히 붙잡으세요!

우선은 확률이 어떤 개념인지 알 필요가 있습니다.

A카드 1장과 B카드 99장을 함께 뒤섞은 후 한장을 뽑았을 때 A카드가 나올 확률은 몇일까요?
잠시 생각해보세요.

...

네, 1/100 입니다.

```
1 / (1 + 99)
```

A카드 30장, B카드 30장, C카드 30장을 섞은 후 한장을 뽑았을때 A카드가 나올 확률은요?

```
30 / (30 + 30 + 30)
```

1 / 3 이군요.

즉 확률이란 전체 경우의 수분에 A 카드가 나올 경우의 수를 찾는 것입니다.
전체 경우의 수란 그냥 모든 경우의 수를 더한 값이죠.

모든 박스에 그 박스가 나올 경우의 수를 주고나면 전체 경우의 수를 알 수 있습니다.
그 박스가 나올 경우의 수를 여기서는 Frequency(빈도)의 약자 Freq라고 하겠습니다.

```
class Box:
	Type = ""
	Value = None
	Freq = 0 # 각 박스가 나올 빈도수
```

이에 맞추어 NewBox 함수에도 빈도를 넣을수 있도록 해야겠군요.

```
def NewBox(type, value, freq):
	b = Box()
	b.Type = type
	b.Value = value
	b.Freq = freq
	return b
```

이제 지난 시간에 정의한 박스들에 각각 원하는 빈도를 넣어보세요.

```
boxes = [
	# 캐릭터 박스
	NewBox("char", "shelly", 100),
	NewBox("char", "nita", 90),
	NewBox("char", "colt", 50),
	NewBox("char", "bull", 10),
	NewBox("char", "leon", 1), # 레전설 캐릭터 leon
	# 코인 박스
	NewBox("coin", 18, 30),
	NewBox("coin", 30, 20),
	NewBox("coin", 50, 10),
	# 보석 박스
	NewBox("gem", 3, 20),
	NewBox("gem", 5, 10),
]
```

이렇게 각 박스가 나올 경우의 수를 정의하고 나면 전체 경우의 수를 찾아낼 수 있겠죠.

```
totalFreq = 0
for b in boxes:
	totalFreq += b.Freq
print(totalFreq)
# 341
```

제 전체 경우의 수는 341 이네요! 다른분들처럼 저도 당연히 전설 캐릭터 leon을 뽑고 싶습니다.
제가 leon을 뽑을 확률은 1/341 이군요... .. . 음.. 화이팅!

확률적으로는 계산이 끝났지만 아직 저희에게 남은 것이 있습니다. 카드를 뽑는 행위를
코드로 작성할 수 있어야 합니다. 이를 위해 저희는 341의 길이를 가진 범위를 정의할 겁니다.
즉 0..340 이죠.

이 범위를 `[0, 341]`이라는 두개의 원소를 지닌 리스트로 바꿀 수 있습니다.
아니요, 341은 오타가 아닙니다.

저는 이 범위를 가장 작은 원소를 포함하되 가장 큰 원소를 포함하지 않는
범위로 표현하려고 합니다. 다들 수학의 정석에서 이런 그림을 한번씩은 본적이 있겠죠?

```
0                               341
●--------------------------------○
```

원이 꽉 차있으면 포함하고 비어있으면 포함하지 않는거죠.

이 방식을 사용하는데는 두가지 이유가 있습니다.

첫번째는 작성해야 할 코드의 양을 줄이기 위해서입니다.
다른 하나는 이 방식이 파이썬이 리스트를 다룰 때 쓰는 방식과 같기 때문입니다.

저희는 이 범위를 각 박스가 차지하게 될 범위로 자를 겁니다.

```
0        100     190    ...     341
●---------○                           : shelly
          ●-------○                   : nita
                  ●----○              : colt
                       ●○             : bull
                        ◎             : neon
                        ●--○          : 18 cash
                           ●-○        : 30 cash
                             ●○       : 50 cash
                              ●-○     : 3 ruby
                                ●○    : 5 ruby
```

코드로는 이렇게 표현할 수 있습니다.

```
ranges = [[0, 100], [100, 190], [190, 240], [240, 250], [250, 251], [251, 281], [281, 301], [301, 311], [311, 331], [331, 341]]
```

여기서 저희는 몇가지 사실을 알 수 있습니다.

- 첫번째 항목의 최솟값은 0이고 마지막 항목의 최댓값은 총 경우의 수(341)이다
- 한 항목(범위)의 최솟값과 최댓값의 차이는 박스의 Freq와 같다
- 앞 항목의 최대값과 뒷 항목의 최솟값이 같다

그렇다면 이렇게 코드를 작성해볼 수 있지 않을까요?

```
ranges = []
# 첫번째 범위의 최솟값은 0 이다.
min = 0
for b in boxes:
	# 각 범위의 최댓값은 최솟값보다 박스의 출현 빈도만큼 크다
	max = min + b.Freq
	ranges.append([min, max])
	# 다음 범위의 최솟값은 이번 범위의 최댓값과 같다.
	min = max
```

이렇게 각 박스의 범위를 지정했으니 random 모듈에서 이 범위 안의 임의의 수를 얻는 함수가 있는지 찾아야 합니다.
원래는 직접 찾으셔야 하지만 친절한 제가 이번만 특별히 알려드릴게요.

```
n = random.randint(0, totalFreq-1) # 0 에서 430사이의 임의의 값을 하나 반환한다.
```

이제 이렇게 뽑은 n이 어느 박스의 범위에 속하는지만 알면 되겠군요!!

```
i = 0
for r in ranges:
	min = r[0]
	max = r[1]
	if n >= min and n < max:
		break
	i += 1
```

이렇게 i번째 박스를 얻게 되었습니다!

```
b = boxes[i]
print(b.Type)
print(b.Value)
```

휴.. 모두 잘 따라오셨나요? 여러분의 한숨소리가 벌써부터 들리는 것 같지만..
포기하지 말고 계속 읽고 실행해보세요. 두세번 코드를 작성하시면 그때부터 감이 올 겁니다.

플레이어가 박스를 깔 때 이 알고리즘을 이용할 수 있다면 더 없이 좋겠네요!
그것은 여러분께 숙제로 남기겠습니다. 모두 leon 꼭 뽑으시길 바라며, 이만 저는 사라집니다. 안녕!

